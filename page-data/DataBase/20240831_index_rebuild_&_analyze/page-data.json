{"componentChunkName":"component---src-templates-blog-post-js","path":"/DataBase/20240831_index_rebuild_&_analyze/","result":{"data":{"site":{"siteMetadata":{"title":"32's Dev.log","author":"han32","siteUrl":"https://gatsby-starter-bee.netlify.com","comment":{"disqusShortName":"","utterances":"HSangMi/devlog"},"sponsor":{"buyMeACoffeeId":"han32"}}},"markdownRemark":{"id":"5d60117f-44fa-57ab-89c1-790a2e2377ca","excerpt":"이전에 말했던 oracle -> postgresql로 이관하는 모 고객사에서, 메인테이블(6천만건 이상) 관련 조회쿼리가 전반적으로 느리다고 지원요청을 받아 분석하게 되었다. 이관 후에 통계정보를 업데이트(analyze) 해보라고 전달했는데 그래도 느리다고 해서 의아했다.\n직접 개발계에 원격을 붙어 분석하면서 분포도가 나쁜 인덱스를 선택하거나, 비교적 간단한 조회문에도 느리게 잡혀서 해당 테이블에 analyze를 날려봤더니 정상속도를 되찾았다.\n알고보니, 유지보수 팀에서 데이터 이관 후 index…","html":"<blockquote>\n<p>이전에 말했던 oracle -> postgresql로 이관하는 모 고객사에서, 메인테이블(6천만건 이상) 관련 조회쿼리가 전반적으로 느리다고 지원요청을 받아 분석하게 되었다.<br>\n이관 후에 통계정보를 업데이트(analyze) 해보라고 전달했는데 그래도 느리다고 해서 의아했다.\n직접 개발계에 원격을 붙어 분석하면서 분포도가 나쁜 인덱스를 선택하거나, 비교적 간단한 조회문에도 느리게 잡혀서 해당 테이블에 analyze를 날려봤더니 정상속도를 되찾았다.\n알고보니, 유지보수 팀에서 데이터 이관 후 index를 생성했기 때문에 통계정보를 업데이트 하지 않아도 될거라 판단한 것.</p>\n</blockquote>\n<p>나도 index rebuild가 통계정보를 업데이트하는 것과 비슷한 맥락이라 생각했던 지라 정확한 차이를 알기위해 GPT한테 물어봤다.</p>\n<hr>\n<p><em>요약 :</em> Index Drop 및 재생성은 인덱스 자체의 재구성을 통해 성능을 직접적으로 개선하는 반면, ANALYZE는 테이블의 데이터 통계를 수집하여 옵티마이저가 더 나은 결정을 내릴 수 있도록 돕습니다.  <br/>\n<strong><code class=\"language-text\">Index 재생성</code></strong>은 <code class=\"language-text\">데이터 액세스 효율성을 향상시키기 위한</code> <strong><code class=\"language-text\">구조적 변화</code></strong>이며,<br>\n<strong><code class=\"language-text\">ANALYZE</code></strong>는 <strong><code class=\"language-text\">옵티마이저의 지능을 높여</code></strong> <code class=\"language-text\">더 나은 쿼리 실행 계획을 수립</code>하게 합니다.  <br/></p>\n<hr>\n<h3 id=\"q1-index를-drop후-새로잡는것과-테이블-analyze하는것은-어떤차이가있지\" style=\"position:relative;\"><a href=\"#q1-index%EB%A5%BC-drop%ED%9B%84-%EC%83%88%EB%A1%9C%EC%9E%A1%EB%8A%94%EA%B2%83%EA%B3%BC-%ED%85%8C%EC%9D%B4%EB%B8%94-analyze%ED%95%98%EB%8A%94%EA%B2%83%EC%9D%80-%EC%96%B4%EB%96%A4%EC%B0%A8%EC%9D%B4%EA%B0%80%EC%9E%88%EC%A7%80\" aria-label=\"q1 index를 drop후 새로잡는것과 테이블 analyze하는것은 어떤차이가있지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Q1. index를 drop후 새로잡는것과 테이블 analyze하는것은 어떤차이가있지?</h3>\n<p>INDEX DROP 및 재생성과 테이블 ANALYZE는 데이터베이스 성능 최적화에서 매우 중요한 역할을 하지만, 그 기능과 목적은 서로 다릅니다.</p>\n<h4 id=\"1-index-drop-및-재생성\" style=\"position:relative;\"><a href=\"#1-index-drop-%EB%B0%8F-%EC%9E%AC%EC%83%9D%EC%84%B1\" aria-label=\"1 index drop 및 재생성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Index Drop 및 재생성</h4>\n<ul>\n<li>\n<p>목적 : 인덱스를 삭제하고 다시 생성하는 것은 주로 다음의 상황에서 이루어집니다</p>\n<ul>\n<li>데이터 재구조화: 테이블의 데이터가 많이 변경되어 기존 인덱스가 비효율적이거나, 인덱스의 통계가 최신 상태가 아니어서 성능이 저하된 경우.</li>\n<li>인덱스 정리: 시간이 지나면서 인덱스가 단편화되거나 비효율적으로 변할 수 있습니다. 이럴 경우 인덱스를 드롭하고 새로 생성하면 성능이 개선될 수 있습니다.</li>\n<li>인덱스 설계 변경: 기존의 인덱스가 최적화되지 않아서, 새로운 컬럼을 포함하거나 순서를 바꾸기 위해 인덱스를 다시 설정하는 경우.</li>\n</ul>\n</li>\n<li>\n<p>효과:</p>\n<ul>\n<li>재정렬: 인덱스를 드롭하고 재생성하면 인덱스 데이터가 새로 정렬되고 구성되며, 이는 인덱스 접근 속도를 개선할 수 있습니다.</li>\n<li>\n<p>단편화 해소: 오래된 인덱스의 단편화를 해결하고 새로운 데이터에 맞춰 최적화된 인덱스를 얻을 수 있습니다.</p>\n<h4 id=\"2-analyze\" style=\"position:relative;\"><a href=\"#2-analyze\" aria-label=\"2 analyze permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. ANALYZE</h4>\n</li>\n</ul>\n</li>\n<li>\n<p>목적:</p>\n<ul>\n<li>ANALYZE 명령어는 테이블의 통계를 수집하여 데이터베이스 옵티마이저가 최적의 쿼리 실행 계획을 수립할 수 있도록 돕습니다. 특히, 데이터 분포, NULL 비율, 레코드 수 등의 정보를 수집합니다.</li>\n</ul>\n</li>\n<li>\n<p>효과:</p>\n<ul>\n<li>최적화된 쿼리 플랜 생성: 옵티마이저는 테이블과 인덱스의 최신 통계에 따라 가장 효율적인 실행 계획을 선택합니다. 따라서, 쿼리 성능이 향상될 수 있습니다.</li>\n<li>통계 정보 갱신: 테이블의 데이터가 변하면서 발생하는 데이터 분포의 변화를 반영하여 통계 정보를 최신 상태로 유지합니다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"q2-index를-drop하고-다시-생성하는-과정에서-analyze작업을-포함하진-않아\" style=\"position:relative;\"><a href=\"#q2-index%EB%A5%BC-drop%ED%95%98%EA%B3%A0-%EB%8B%A4%EC%8B%9C-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C-analyze%EC%9E%91%EC%97%85%EC%9D%84-%ED%8F%AC%ED%95%A8%ED%95%98%EC%A7%84-%EC%95%8A%EC%95%84\" aria-label=\"q2 index를 drop하고 다시 생성하는 과정에서 analyze작업을 포함하진 않아 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Q2. index를 drop하고 다시 생성하는 과정에서 analyze작업을 포함하진 않아?</h3>\n<h4 id=\"인덱스를-드롭하고-다시-생성하는-과정에서-자동으로-analyze-작업이-수행되지는-않습니다\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4%EB%A5%BC-%EB%93%9C%EB%A1%AD%ED%95%98%EA%B3%A0-%EB%8B%A4%EC%8B%9C-%EC%83%9D%EC%84%B1%ED%95%98%EB%8A%94-%EA%B3%BC%EC%A0%95%EC%97%90%EC%84%9C-%EC%9E%90%EB%8F%99%EC%9C%BC%EB%A1%9C-analyze-%EC%9E%91%EC%97%85%EC%9D%B4-%EC%88%98%ED%96%89%EB%90%98%EC%A7%80%EB%8A%94-%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"인덱스를 드롭하고 다시 생성하는 과정에서 자동으로 analyze 작업이 수행되지는 않습니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>인덱스를 드롭하고 다시 생성하는 과정에서 자동으로 ANALYZE 작업이 수행되지는 않습니다.</h4>\n<ul>\n<li>\n<p>세부 사항:</p>\n<ul>\n<li>인덱스 생성: 인덱스를 다시 생성할 때, 데이터베이스는 해당 인덱스를 최적화하고 정렬하여 쿼리 성능을 향상시킵니다. 이 과정은 인덱스 자체에 대한 작업이며, 테이블의 데이터에 대한 통계 정보를 갱신하는 과정은 포함되지 않습니다.</li>\n</ul>\n</li>\n<li>ANALYZE 필요성: 인덱스를 새로 생성한 후에는, 테이블에 대한 통계 정보가 최신 상태로 갱신되지 않기 때문에, 옵티마이저가 최적의 쿼리 실행 계획을 선택하는 데 문제가 발생할 수 있습니다. 따라서 인덱스를 재생성한 후에 ANALYZE를 실행하는 것이 권장됩니다. 이는 데이터베이스가 테이블과 인덱스에 대한 최신 통계 정보를 수집하고, 이를 바탕으로 더 나은 쿼리 계획을 세울 수 있도록 돕기 위함입니다.</li>\n<li>\n<p>요약:</p>\n<ul>\n<li>인덱스를 드롭하고 다시 생성하는 작업 자체는 ANALYZE를 포함하지 않으며, 별도로 ANALYZE 명령어를 실행해야 합니다.</li>\n<li>인덱스를 재생성한 후에는 테이블에 대해 ANALYZE를 수행하는 것이 좋습니다. 이는 최신 통계 정보를 데이터베이스에 제공하여 성능을 최적화할 수 있기 때문입니다.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<p>오늘도 하나 배워갑니다.😀</p>","frontmatter":{"title":"[성능개선] index rebuild vs analyze","date":"August 31, 2024","tags":["SQL","workLog"]}}},"pageContext":{"slug":"/DataBase/20240831_index_rebuild_&_analyze/","previous":{"fields":{"slug":"/DataBase/20240829_procedure_query_plan/"},"frontmatter":{"title":"[Postgresql] 프로시저 내부 실행계획 - 부제 : 실행계획은 문제없는거 같은데 왜 점점 느려질까?","category":"Database/SQL"}},"next":{"fields":{"slug":"/CategoryDivider/language/"},"frontmatter":{"title":"Language","category":"Language"}}}}}